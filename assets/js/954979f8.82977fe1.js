"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9707],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,f=u["".concat(c,".").concat(m)]||u[m]||p[m]||o;return n?r.createElement(f,s(s({ref:t},d),{},{components:n})):r.createElement(f,s({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4261:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));n(8209);const o={id:"examples",title:"Smart Contracts - Examples",sidebar_label:"Examples",sidebar_position:5},s=void 0,i={unversionedId:"build/smart-contracts/language/examples",id:"build/smart-contracts/language/examples",title:"Smart Contracts - Examples",description:"Hello World",source:"@site/docs/build/smart-contracts/language/examples.md",sourceDirName:"build/smart-contracts/language",slug:"/build/smart-contracts/language/examples",permalink:"/build/smart-contracts/language/examples",draft:!1,tags:[],version:"current",lastUpdatedAt:1702631276,formattedLastUpdatedAt:"Dec 15, 2023",sidebarPosition:5,frontMatter:{id:"examples",title:"Smart Contracts - Examples",sidebar_label:"Examples",sidebar_position:5},sidebar:"docs",previous:{title:"Library",permalink:"/build/smart-contracts/language/library"},next:{title:"Legacy",permalink:"/build/smart-contracts/language/legacy/"}},c={},l=[{value:"Hello World",id:"hello-world",level:2},{value:"ICO (Initial Coin Offering)",id:"ico-initial-coin-offering",level:2},{value:"Recurring ICO",id:"recurring-ico",level:2},{value:"Vote system",id:"vote-system",level:2}],d={toc:l},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"hello-world"},"Hello World"),(0,a.kt)("p",null,'This simple contract will be triggered once, at the specified unix timestamp.\nIt will create a new transaction with a content "Hello world!".'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\n\nactions triggered_by: datetime, at: 1689857160 do\n  Contract.set_content("Hello world!")\nend\n')),(0,a.kt)("h2",{id:"ico-initial-coin-offering"},"ICO (Initial Coin Offering)"),(0,a.kt)("p",null,"This contract the crowdsale of an ICO."),(0,a.kt)("p",null,"Users can send UCOs to this contract and will receive 10000 times the amount as token from this contract."),(0,a.kt)("p",null,"It is possible for users to define a different receive address."),(0,a.kt)("p",null,"The Smart Contract's chain must define a token."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\n\ncondition triggered_by: transaction, on: buyToken(recipient_address), as: [\n    uco_transfers: check_amount(transaction.uco_movements)\n]\n\nactions triggered_by: transaction, on: buyToken(recipient_address) do\n    transfers = get_transfered_amount()\n\n    # Get the amount of UCO sent to this contract\n    amount_send = number_of_uco_sent()\n\n    # Convert UCO to the number of tokens to credit. Each UCO worth 10000 token\n    token_to_credit = number_of_tokens(amount_send)\n\n    Contract.set_type("transfer")\n\n    # Users can specify to send the token in a different address\n    Contract.add_token_transfer(to: recipient_address, token_address: token_address(), amount: token_to_credit)\nend\n\nfun number_of_tokens(uco_amount) do\n  uco_amount * 10000\nend\n\nfun number_of_uco_sent() do\n  Map.get(transaction.uco_movements, contract.address)\nend\n\nfun get_transfered_amount() do\n  Map.get(transaction.uco_transfers, contract.address)\nend\n\nfun check_amount(transfers) do  \n  transfered_amount = Map.get(transfers, contract.address)\n  transfered_amount != nil && transfered_amount > 0\nend\n\nfun token_address() do\n  Chain.get_genesis_address(contract.address)\nend\n\n')),(0,a.kt)("h2",{id:"recurring-ico"},"Recurring ICO"),(0,a.kt)("p",null,"This contract will automatically call the ICO contract with 2 UCOs every hours.\nThe tokens will be transfered in a different chain."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\n\nactions triggered_by: interval, at: "0 * * * *" do\n\n    ico_contract = 0x0000993F3BE0CE40541E47735AA083854ECAC7785B39435C90D8456C777B9E9D81F1\n\n    Contract.set_type("transfer")\n    Contract.add_recipient(address: ico_contract, action: "buyToken", args: [0x0000A3A066DD64FBD51AE384F2383684B3803BC72012BFEAA9CD1C93AB7C60F584DC])\n    Contract.add_uco_transfer(to: ico_contract, amount: 2)\nend\n')),(0,a.kt)("h2",{id:"vote-system"},"Vote system"),(0,a.kt)("p",null,"This contract counts the number of votes for list of candidates (Mr.X and Mrs.Y)."),(0,a.kt)("p",null,"For each vote request, it increments the number of votes for the given candidate,\nand create a new transaction out of it, with the new state in the ",(0,a.kt)("inlineCode",{parentName:"p"},"content")," field of the transaction as JSON document."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"A public function is available to be able to easily query the number of votes in the system")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\ncondition triggered_by: transaction, on: vote(candidate), as: [\n    content: List.in?(["X", "Y"], candidate)\n]\n\nactions triggered_by: transaction, on: vote(candidate) do\n    votes = []\n\n    if contract.content == "" do\n      votes = add_vote([x: 0, y: 0], candidate)\n    else\n      votes = get_votes()\n      votes = add_vote(votes, candidate)\n    end\n\n    Contract.set_content(Json.to_string(votes))\nend\n\nfun add_vote(votes, candidate) do\n  if candidate == "X" do\n    Map.set(votes, "x", votes.x + 1)\n  else\n    Map.set(votes, "y", votes.y + 1)\n  end\nend\n\nexport fun get_votes() do\n  count_x = Json.path_extract(contract.content, "$.x")\n  count_y = Json.path_extract(contract.content, "$.y")\n  [x: count_x, y: count_y]\nend\n')))}p.isMDXComponent=!0},8209:(e,t,n)=>{n(7294)}}]);