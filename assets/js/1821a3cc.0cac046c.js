"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7945],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>_});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),c=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(d.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=c(n),p=a,_=u["".concat(d,".").concat(p)]||u[p]||m[p]||o;return n?r.createElement(_,s(s({ref:t},l),{},{components:n})):r.createElement(_,s({ref:t},l))}));function _(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[u]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},65240:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));n(8209);const o={id:"examples",title:"Smart Contracts - Examples",sidebar_label:"Examples",sidebar_position:6},s=void 0,i={unversionedId:"build/smart-contracts/examples",id:"build/smart-contracts/examples",title:"Smart Contracts - Examples",description:"Hello World",source:"@site/docs/build/smart-contracts/examples.md",sourceDirName:"build/smart-contracts",slug:"/build/smart-contracts/examples",permalink:"/build/smart-contracts/examples",draft:!1,tags:[],version:"current",lastUpdatedAt:1733153244,formattedLastUpdatedAt:"Dec 2, 2024",sidebarPosition:6,frontMatter:{id:"examples",title:"Smart Contracts - Examples",sidebar_label:"Examples",sidebar_position:6},sidebar:"docs",previous:{title:"Fees",permalink:"/build/smart-contracts/fees"},next:{title:"Playground",permalink:"/build/smart-contracts/playground/"}},d={},c=[{value:"Hello World",id:"hello-world",level:2},{value:"ICO (Initial Coin Offering)",id:"ico-initial-coin-offering",level:2},{value:"Recurring ICO",id:"recurring-ico",level:2},{value:"Vote system",id:"vote-system",level:2},{value:"Insurance &quot;at least 25\xb0c&quot;",id:"insurance-at-least-25c",level:2}],l={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"hello-world"},"Hello World"),(0,a.kt)("p",null,'This simple contract will be triggered once, at the specified unix timestamp.\nIt will create a new transaction with a content "Hello world!".'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\n\nactions triggered_by: datetime, at: 1689857160 do\n  Contract.set_content("Hello world!")\nend\n')),(0,a.kt)("h2",{id:"ico-initial-coin-offering"},"ICO (Initial Coin Offering)"),(0,a.kt)("p",null,"This contract the crowdsale of an ICO."),(0,a.kt)("p",null,"Users can send UCOs to this contract and will receive 10000 times the amount as token from this contract."),(0,a.kt)("p",null,"It is possible for users to define a different receive address."),(0,a.kt)("p",null,"The Smart Contract's chain must define a token."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\n\ncondition triggered_by: transaction, on: buyToken(recipient_address) do\n  transfered_amount = Map.get(transaction.uco_movements, contract.address)\n  transfered_amount != nil && transfered_amount > 0\nend\n\nactions triggered_by: transaction, on: buyToken(recipient_address) do\n    transfers = get_transfered_amount()\n\n    # Get the amount of UCO sent to this contract\n    amount_send = number_of_uco_sent()\n\n    # Convert UCO to the number of tokens to credit. Each UCO worth 10000 token\n    token_to_credit = number_of_tokens(amount_send)\n\n    Contract.set_type("transfer")\n\n    # Users can specify to send the token in a different address\n    Contract.add_token_transfer(to: recipient_address, token_address: token_address(), amount: token_to_credit)\nend\n\nfun number_of_tokens(uco_amount) do\n  uco_amount * 10000\nend\n\nfun number_of_uco_sent() do\n  Map.get(transaction.uco_movements, contract.address)\nend\n\nfun get_transfered_amount() do\n  Map.get(transaction.uco_transfers, contract.address)\nend\n\nfun token_address() do\n  Chain.get_genesis_address(contract.address)\nend\n\n')),(0,a.kt)("h2",{id:"recurring-ico"},"Recurring ICO"),(0,a.kt)("p",null,"This contract will automatically call the ICO contract with 2 UCOs every hours.\nThe tokens will be transfered in a different chain."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\n\nactions triggered_by: interval, at: "0 * * * *" do\n\n    ico_contract = 0x0000993F3BE0CE40541E47735AA083854ECAC7785B39435C90D8456C777B9E9D81F1\n\n    Contract.set_type("transfer")\n    Contract.add_recipient address: ico_contract, action: "buyTokens", args: [0x0000A3A066DD64FBD51AE384F2383684B3803BC72012BFEAA9CD1C93AB7C60F584DC]\n    Contract.add_uco_transfer(amount: 2, to: ico_contract)\nend\n')),(0,a.kt)("h2",{id:"vote-system"},"Vote system"),(0,a.kt)("p",null,'This contract counts the number of votes for list of candidates ("Miss Scarlett", "Colonel Mustard").\nFor each vote request, it increments the number of votes for the given candidate.\nA voter can only vote once because the contract keep track of the voters genesis addresses.'),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"A public function is available to be able to easily query the number of votes in the system")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\ncondition triggered_by: transaction, on: vote(candidate) do\n    if !List.in?(["Miss Scarlett", "Colonel Mustard"], candidate) do\n      throw code: 1, message: "unknown candidate", data: candidate\n    end\n\n    voters_genesis_addresses = State.get("voters_genesis_addresses", [])\n    voter_genesis_address = Chain.get_genesis_address(transaction.address)\n\n    if List.in?(voters_genesis_addresses, voter_genesis_address) do\n      throw code: 2, message: "already voted", data: [\n        address: transaction.address,\n        genesis: voter_genesis_address\n      ]\n    end\n\n    true\nend\n\nactions triggered_by: transaction, on: vote(candidate) do\n    scarlett_votes = State.get("Miss Scarlett", 0)\n    mustard_votes = State.get("Colonel Mustard", 0)\n    voters = State.get("voters_genesis_addresses", [])\n\n    if candidate == "Miss Scarlett" do\n      scarlett_votes = scarlett_votes + 1\n    end\n    if candidate == "Colonel Mustard" do\n      mustard_votes = mustard_votes + 1\n    end\n\n    # Add the current voter genesis address to the list\n    # So he/she cannot vote twice\n    voters = List.prepend(voters, Chain.get_genesis_address(transaction.address))\n\n    State.set("Miss Scarlett", scarlett_votes)\n    State.set("Colonel Mustard", mustard_votes)\n    State.set("voters_genesis_addresses", voters)\nend\n\nexport fun get_votes() do\n  [\n    scarlett: State.get("Miss Scarlett", 0),\n    mustard: State.get("Colonel Mustard", 0)\n  ]\nend\n')),(0,a.kt)("h2",{id:"insurance-at-least-25c"},'Insurance "at least 25\xb0c"'),(0,a.kt)("p",null,"This Smart Contract holds some funds, and send them all to either the insurance company or the insuree at the end of the stay. The receiver is determined by the average temperature at destination during the stay."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-elixir"},'@version 1\n\n# float, float, string, string :: List float\nfun get_hourly_temperatures(lat, long, start_date, end_date) do\n # TODO: fetch multiple sources\n response = Http.request("https://archive-api.open-meteo.com/v1/archive?latitude=#{lat}&longitude=#{long}&start_date=#{start_date}&end_date=#{end_date}&hourly=temperature_2m")\n if response.status == 200 && Json.is_valid?(response.body) do\n   json = Json.parse(response.body)\n   json.hourly.temperature_2m\n else\n   []\n end\nend\n\n# List float -> float\nfun average(xs) do\n    sum = 0\n    count = 0\n    for x in xs do\n      count = count + 1\n      sum = sum + x\n    end\n\n sum / count\nend\n\n# Trigger at the end of stay\nactions triggered_by: datetime, at: 1694728800 do\n  insurance_company_wallet = 0x00002223BBD4EC3D64AE597696C7D7ADE1CEE65C639D885450AD2D7B75592AC76AFA\n  insuree_wallet = 0x0000238C3A9CB5BFB7A863D698B71DFFF0C9C5C40CFF21EBDA2D83EBAEDDA1C6E10D\n  lat = 41.591\n  long = 9.2795\n  start_date = "2023-09-08"\n  end_date = "2023-09-15"\n  threshold = 25\n  amount = 4000\n\n\n  hourly_temperatures = get_hourly_temperatures(lat, long, start_date, end_date)\n\n  if hourly_temperatures == [] do\n    # No data? arbitrary decision of splitting 50/50\n    # To better deal with that situation, fetch multiple sources instead of a single one\n    Contract.set_content("No average temperature available")\n    Contract.add_uco_transfer to: insurance_company_wallet, amount: amount / 2\n    Contract.add_uco_transfer to: insuree_wallet, amount: amount / 2\n  else\n    average_temperature = average(hourly_temperatures)\n\n    Contract.set_content("Average temperature was: #{average_temperature}")\n    if average_temperature >= threshold do\n      Contract.add_uco_transfer to: insurance_company_wallet, amount: amount\n    else\n      Contract.add_uco_transfer to: insuree_wallet, amount: amount\n    end\n  end\nend\n')))}m.isMDXComponent=!0},8209:(e,t,n)=>{n(67294)}}]);