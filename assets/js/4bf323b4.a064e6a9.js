"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1601],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,k=u["".concat(s,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(k,l(l({ref:t},c),{},{components:n})):a.createElement(k,l({ref:t},c))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},61544:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));n(8209);const r={id:"language",title:"Smart Contracts - Language",sidebar_label:"Language",sidebar_position:2},l=void 0,o={unversionedId:"build/smart-contracts/language/language",id:"build/smart-contracts/language/language",title:"Smart Contracts - Language",description:"A Smart Contract is defined as followed:",source:"@site/docs/build/smart-contracts/language/README.md",sourceDirName:"build/smart-contracts/language",slug:"/build/smart-contracts/language/",permalink:"/build/smart-contracts/language/",draft:!1,tags:[],version:"current",lastUpdatedAt:1732562836,formattedLastUpdatedAt:"Nov 25, 2024",sidebarPosition:2,frontMatter:{id:"language",title:"Smart Contracts - Language",sidebar_label:"Language",sidebar_position:2},sidebar:"docs",previous:{title:"Smart Contracts",permalink:"/build/smart-contracts/"},next:{title:"Triggers",permalink:"/build/smart-contracts/language/triggers"}},s={},p=[{value:"Version attribute",id:"version-attribute",level:2},{value:"Basic Types",id:"basic-types",level:2},{value:"Hexadecimals",id:"hexadecimals",level:2},{value:"ASCII character in string",id:"ascii-character-in-string",level:2},{value:"Comparaison",id:"comparaison",level:2},{value:"Arithmetic",id:"arithmetic",level:2},{value:"Ranges",id:"ranges",level:2},{value:"Loop",id:"loop",level:2},{value:"Variables &amp; Scopes",id:"variables--scopes",level:2},{value:"Lists",id:"lists",level:2},{value:"Maps",id:"maps",level:2},{value:"Functions",id:"functions",level:2},{value:"Internal Functions",id:"internal-functions",level:3},{value:"Exported Functions",id:"exported-functions",level:3},{value:"Library",id:"library",level:2},{value:"Errors",id:"errors",level:2},{value:"Reserved keywords",id:"reserved-keywords",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A Smart Contract is defined as followed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"1 version attribute"),(0,i.kt)("li",{parentName:"ul"},"n ",(0,i.kt)("a",{parentName:"li",href:"/build/smart-contracts/language/actions"},"actions")," block (maximum, one per ",(0,i.kt)("a",{parentName:"li",href:"/build/smart-contracts/language/triggers"},"trigger"),")"),(0,i.kt)("li",{parentName:"ul"},"0 or 1 ",(0,i.kt)("a",{parentName:"li",href:"/build/smart-contracts/language/condition#inherit"},"condition inherit")," block"),(0,i.kt)("li",{parentName:"ul"},"0 or 1 ",(0,i.kt)("a",{parentName:"li",href:"/build/smart-contracts/language/condition#transaction"},"condition transaction")," block"),(0,i.kt)("li",{parentName:"ul"},"n ",(0,i.kt)("a",{parentName:"li",href:"/build/smart-contracts/language/condition#transaction"},"condition transaction on")," block"),(0,i.kt)("li",{parentName:"ul"},"0 or 1 ",(0,i.kt)("a",{parentName:"li",href:"/build/smart-contracts/language/condition#oracle"},"condition oracle")," block")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"actions")," blocks contain the code to execute when a specific event is triggered."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"condition inherit")," block is used to check the outgoing transaction (result) of the contract."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"condition transaction")," block is used to check the incoming transaction that triggered the contract."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"condition oracle")," block is used to check the incoming oracle transaction when there is an action triggered by oracle."),(0,i.kt)("h2",{id:"version-attribute"},"Version attribute"),(0,i.kt)("p",null,"A version attribute must be specified on the first line of the code. This version is used by the interpreter to have the right behavior in case of breaking changes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},"@version 1\n# Rest of the code\n")),(0,i.kt)("h2",{id:"basic-types"},"Basic Types"),(0,i.kt)("p",null,"This language is based on a functional language (elixir), but we added some imperative twist to it, to make it friendlier!"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Comments are lines that start with a ",(0,i.kt)("inlineCode",{parentName:"li"},"#")),(0,i.kt)("li",{parentName:"ul"},"Strings are double quoted ",(0,i.kt)("inlineCode",{parentName:"li"},'"I am a string"')),(0,i.kt)("li",{parentName:"ul"},"String interpolation ",(0,i.kt)("inlineCode",{parentName:"li"},'"hello #{name}"')),(0,i.kt)("li",{parentName:"ul"},"Integers & Floats can use ",(0,i.kt)("inlineCode",{parentName:"li"},"_")," at your convenience ",(0,i.kt)("inlineCode",{parentName:"li"},"10_000")," ",(0,i.kt)("inlineCode",{parentName:"li"},"10_000.0")),(0,i.kt)("li",{parentName:"ul"},"Floats can use the scientific format: ",(0,i.kt)("inlineCode",{parentName:"li"},"1.0e2 == 100")),(0,i.kt)("li",{parentName:"ul"},"Booleans syntax: ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"false")),(0,i.kt)("li",{parentName:"ul"},"The absence of value: ",(0,i.kt)("inlineCode",{parentName:"li"},"nil"))),(0,i.kt)("h2",{id:"hexadecimals"},"Hexadecimals"),(0,i.kt)("p",null,"In the Archethic blockchain, we extensively uses hexadecimals to convert all addresses, public keys or hashes on the user-facing interfaces. A Smart Contract is one of these interfaces."),(0,i.kt)("p",null,"To reduce the possibility of errors when comparing hexadecimals (",(0,i.kt)("inlineCode",{parentName:"p"},'"000ABCD" != "000abcd"')," even if it's actually the same value), we introduced a new syntax: ",(0,i.kt)("inlineCode",{parentName:"p"},"0x"),". The goal of this syntax is only to facilitate comparaison: ",(0,i.kt)("inlineCode",{parentName:"p"},"0x000ABCD == 0x000abcd"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},'# don\'t\ntransaction.address == "000ABCD123"\n\n# do\ntransaction.address == 0x000ABCD123 # no quotes!\n')),(0,i.kt)("p",null,"So whenever you write a hexadecimal value by hand, prefix it with ",(0,i.kt)("inlineCode",{parentName:"p"},"0x"),"."),(0,i.kt)("h2",{id:"ascii-character-in-string"},"ASCII character in string"),(0,i.kt)("p",null,"If you need to use some specific character in a string, you can use their hexadecimal representation by prefixing the hexadecimal with ",(0,i.kt)("inlineCode",{parentName:"p"},"\\x")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},'"hello" == "\\x68\\x65\\x6C\\x6C\\x6F"\n# true\n')),(0,i.kt)("h2",{id:"comparaison"},"Comparaison"),(0,i.kt)("p",null,"We compare by value, which means you can pretty much compare anything and it will work as you expect."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 == 1.0")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1,2] == [1,2]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'[name: "John"] == [name: "John"]')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"!true == false")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"true != false")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"if <expr> do ... end")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"if <expr> do ... else ... end"))),(0,i.kt)("h2",{id:"arithmetic"},"Arithmetic"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 + 2 == 3")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2.0 - 1.1 == 0.9")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 * 2.0 == 2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 / 1 == 1.0")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 / 0")," contract failure")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The arithmetic is done with the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ericmj/decimal"},"Decimal library")," to ensure there is no floating point precision issue.\n",(0,i.kt)("strong",{parentName:"p"},"The only thing to keep in mind is that we truncate at decimal 8."))),(0,i.kt)("h2",{id:"ranges"},"Ranges"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1..5")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"[1,2,3,4,5]"))),(0,i.kt)("h2",{id:"loop"},"Loop"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"for name in names do ... end")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"for i in 1..10 do ... end"))),(0,i.kt)("h2",{id:"variables--scopes"},"Variables & Scopes"),(0,i.kt)("p",null,"Variables are not typed, you can assign any value to them."),(0,i.kt)("p",null,"Variables are mutable, if you update a variable declared in a parent scope, it will also update the value of this variable for the parent scope."),(0,i.kt)("p",null,"A new scope is created every time you enter a new block (",(0,i.kt)("inlineCode",{parentName:"p"},"do .. end"),"). A scope can access (read/write) the variables declared in its parent's scope, but not its child's scope."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},'names = ["Tom", "Jerry", ""]\ntext = ""\nfor name in names do                # ENTER SCOPE 1\n    if name != "" do                # ENTER SCOPE 1.1\n        new_line = "\\n"\n        text = "#{name}#{new_line}"\n    end                             # EXIT SCOPE 1.1\n    # new_line does not exists here\nend                                 # EXIT SCOPE 1\n# test = "Tom\\nJerry\\n"\n# name and new_line does not exists here\n')),(0,i.kt)("p",null,"Here's the tree of scopes and variables for the above example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[SCOPE 0]\n\u251c\u2500\u2500 names\n\u251c\u2500\u2500 text\n\u2514\u2500\u2500 [SCOPE 1]\n    \u251c\u2500\u2500 name\n    \u2514\u2500\u2500 [SCOPE 1.1]\n        \u2514\u2500\u2500 new_line\n")),(0,i.kt)("h2",{id:"lists"},"Lists"),(0,i.kt)("p",null,"The list is the data structure to work with collections. The syntax is: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 2]"),". An empty list is: ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),".\nThere is a ",(0,i.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/library#list"},"List module")," in the library to manipulate lists."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Lists are actually ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linked_list"},"Linked Lists"),".")),(0,i.kt)("h2",{id:"maps"},"Maps"),(0,i.kt)("p",null,"The map is the key-value data structure in the Smart Contract language. The syntax is: ",(0,i.kt)("inlineCode",{parentName:"p"},"[key1: 1, key2: 2]")," or if key starts with a number: ",(0,i.kt)("inlineCode",{parentName:"p"},'["00001abc...": 1]'),". The keys must be strings.\nThere is 3 ways to retrieve a value:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"map.property")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'map["property"]')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'Map.get(map, "property")'))),(0,i.kt)("p",null,"We suggest to use the 1st syntax as often as possible. Use the 2nd or 3rd when dealing with dynamic properties."),(0,i.kt)("p",null,"There is a ",(0,i.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/library#map"},"Map module")," module in the library to manipulate maps."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Since the maps and the lists have a very close syntax, it is impossible to differentiate an empty map from an empty list. So, for semantic reasons, to create an empty map, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.new()")," function call.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The brackets are mostly optional! ",(0,i.kt)("inlineCode",{parentName:"p"},"key1: 1, key2: 2")," will work as well. But if you have a nested map, you cannot omit them!")),(0,i.kt)("h2",{id:"functions"},"Functions"),(0,i.kt)("p",null,"In the Archethic Smart Contract Language, you can declare 2 types of functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Internal Functions declared with the ",(0,i.kt)("inlineCode",{parentName:"li"},"fun")," keyword"),(0,i.kt)("li",{parentName:"ul"},"Exported Functions declared with the ",(0,i.kt)("inlineCode",{parentName:"li"},"export fun")," keyword")),(0,i.kt)("h3",{id:"internal-functions"},"Internal Functions"),(0,i.kt)("p",null,"Internal functions are functions that are only available in the Smart Contract. They are not callable from the outside."),(0,i.kt)("p",null,"They are declared with the ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," keyword and can be called from the ",(0,i.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/actions"},"Action")," or ",(0,i.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/condition"},"Condition")," blocks."),(0,i.kt)("p",null,"They can have 0 argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},'fun hello() do\n    "Hello World!"\nend\n')),(0,i.kt)("p",null,"Or more:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},"fun sum(a, b) do\n    a + b\nend\n")),(0,i.kt)("p",null,"You can also have the same function name with different signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},"fun sum(a, b) do\n    a + b\nend\n\nfun sum(list) do\n    acc = 0\n    for i in list do\n        acc = acc + i\n    end\n    acc\nend\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"These functions aren't able to call another internal function")," but can call an Exported one."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Internal functions are able to use ",(0,i.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/library"},"library module")," functions tagged as ",(0,i.kt)("inlineCode",{parentName:"p"},"I/O")," but not the functions tagged as ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE_CONTRACT"),".")),(0,i.kt)("h3",{id:"exported-functions"},"Exported Functions"),(0,i.kt)("p",null,"Exported functions are callable from the Smart Contract but also through the outside via the JSON-RPC API.\nThey are declared like internal function but with the ",(0,i.kt)("inlineCode",{parentName:"p"},"export fun")," syntax."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},'export fun get_current_count() do\n    State.get("count")\nend\n')),(0,i.kt)("p",null,"Unlike internal functions, they can be called from any block of code."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"External functions are not able to use ",(0,i.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/library"},"library module")," functions tagged as ",(0,i.kt)("inlineCode",{parentName:"p"},"I/O")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction"),".")),(0,i.kt)("h2",{id:"library"},"Library"),(0,i.kt)("p",null,"You may use any functions from the library. The syntax is ",(0,i.kt)("inlineCode",{parentName:"p"},"Module.function(arg1, arg2)"),"."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The parenthesis are actually optional! ",(0,i.kt)("inlineCode",{parentName:"p"},"Module.function arg1, arg2")," will work as well.")),(0,i.kt)("p",null,"To see the list of functions available in the Smart Contract Language, check the ",(0,i.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/library"},"Library page"),"."),(0,i.kt)("h2",{id:"errors"},"Errors"),(0,i.kt)("p",null,"We introduced in v1.5.0 the ",(0,i.kt)("inlineCode",{parentName:"p"},"throw")," keyword. It's useful to provide insightful errors to the end users and helps the dApp developers interacting with contracts."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},'if Crypto.hash(secret) != State.get("secret_hash") do\n  throw code: 1, message: "invalid secret", data: secret\nend\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"throw")," takes a map with the following keys:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"code"),": an integer of your choice that dApp developers may use to react on a specific error. ",(0,i.kt)("strong",{parentName:"li"},"It should be uniquely identifiable within the contract.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"message"),": a string describing the error."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data")," ",(0,i.kt)("em",{parentName:"li"},"(opt)"),": some context relevant to the error (can be any type).")),(0,i.kt)("h2",{id:"reserved-keywords"},"Reserved keywords"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"for")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"do")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"end")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"if")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"else"))),(0,i.kt)("p",null,"... to be completed"))}d.isMDXComponent=!0},8209:(e,t,n)=>{n(67294)}}]);