"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1938],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||i;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},57751:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));n(8209);const i={id:"condition",title:"Smart Contracts - Condition block",sidebar_label:"Condition",sidebar_position:2},o=void 0,s={unversionedId:"build/smart-contracts/language/condition",id:"build/smart-contracts/language/condition",title:"Smart Contracts - Condition block",description:"Conditions are blocks which purpose is to check the validity of a transaction.",source:"@site/docs/build/smart-contracts/language/condition.md",sourceDirName:"build/smart-contracts/language",slug:"/build/smart-contracts/language/condition",permalink:"/build/smart-contracts/language/condition",draft:!1,tags:[],version:"current",lastUpdatedAt:1743006741,formattedLastUpdatedAt:"Mar 26, 2025",sidebarPosition:2,frontMatter:{id:"condition",title:"Smart Contracts - Condition block",sidebar_label:"Condition",sidebar_position:2},sidebar:"docs",previous:{title:"Triggers",permalink:"/build/smart-contracts/language/triggers"},next:{title:"Actions",permalink:"/build/smart-contracts/language/actions"}},l={},c=[{value:"Boolean expressions",id:"boolean-expressions",level:2},{value:"Rules",id:"rules",level:3},{value:"Condition inherit",id:"condition-inherit",level:2},{value:"Examples",id:"examples",level:3},{value:"Condition triggered by a transaction",id:"condition-triggered-by-a-transaction",level:2},{value:"Examples",id:"examples-1",level:3},{value:"Condition triggered by an oracle",id:"condition-triggered-by-an-oracle",level:2},{value:"Examples",id:"examples-2",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Conditions are blocks which purpose is to check the validity of a transaction."),(0,r.kt)("p",null,"There are 3 types of ",(0,r.kt)("inlineCode",{parentName:"p"},"condition")," block:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#condition-inherit"},"inherit")," (optional)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#condition-transaction"},"transaction")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#condition-oracle"},"oracle"))),(0,r.kt)("p",null,"There are 2 differents forms. You may use whichever is the more suitable for you."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},"condition triggered_by: oracle do\n  <expr that returns a boolean>\nend\n\ncondition triggered_by: transaction, on: <action> do\n  <expr that returns a boolean>\nend\n\n# boolean expressions form\ncondition inherit: [\n    <prop1>: <value>,\n    <prop2>: <boolean>,\n    <prop3>: <expr that returns a value>,\n    <prop4>: <expr that returns a boolean>\n]\n\n# legacy: before there were named actions, there was only one possible action\ncondition transaction: [\n  <prop1>: <value>,\n  <prop2>: <boolean>,\n  <prop3>: <expr that returns a value>,\n  <prop4>: <expr that returns a boolean>\n]\n\n# legacy: old syntax\ncondition oracle: [\n  <prop1>: <value>,\n  <prop2>: <boolean>,\n  <prop3>: <expr that returns a value>,\n  <prop4>: <expr that returns a boolean>\n]\n")),(0,r.kt)("admonition",{title:"throw keyword",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/#errors"},(0,r.kt)("inlineCode",{parentName:"a"},"throw"))," keyword is another way to reject a condition. It stops the evaluation of the condition and rejects it with a ",(0,r.kt)("inlineCode",{parentName:"p"},"code"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"message")," and optionaly some ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),".")),(0,r.kt)("h2",{id:"boolean-expressions"},"Boolean expressions"),(0,r.kt)("p",null,"It is a map where the keys are the ",(0,r.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/actions#appendix-1-the-transaction-map"},"transaction's fields"),", and the values are expressions that must return a boolean or a value.\nThey work for any conditions type, but we suggest to use them with the inherit conditions only."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition inherit: [\n    # <value>\n    # all the transactions of this chain will be of type "contract"\n    type: "contract",\n\n    # <boolean>\n    # the content is mutable\n    content: true,\n\n    # <expr that returns a boolean>\n    # all the transactions must contains at least 1 UCO transfers\n    # here uco_transfers is automatically given as 1st argument of Map.size()\n    uco_transfers: Map.size() > 0\n]\n')),(0,r.kt)("h3",{id:"rules"},"Rules"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},'All "boolean expressions" must pass for the transaction to be valid.')),(0,r.kt)("li",{parentName:"ol"},'If the expression returns true, this "boolean expression" passes.'),(0,r.kt)("li",{parentName:"ol"},'If the expression returns false, this "boolean expression" fails.'),(0,r.kt)("li",{parentName:"ol"},'If the expression returns a value, this "boolean expression" passes if the transaction\'s property has the same value.')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"In these blocks, there is also some sugar to automatically add the property as an argument of the functions called. For example ",(0,r.kt)("inlineCode",{parentName:"p"},"uco_transfers: Map.size() > 0")," will automatically expand to ",(0,r.kt)("inlineCode",{parentName:"p"},"uco_transfers: Map.size(transaction.uco_transfers) > 0"),".")),(0,r.kt)("h2",{id:"condition-inherit"},"Condition inherit"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"condition inherit")," purpose is to check the next transaction generated by the smart contract after its code execution. It ensures the next transaction respects specific rules so the smart contract chain cannot be compromised.\nIt is automatically forwarded from transaction to transaction unless it is manually overriden."),(0,r.kt)("p",null,"There are 2 global variables for this condition block:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"previous")," is the transaction of the current contract."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"next"),' is the "next transaction".')),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/actions#appendix-1-the-transaction-map"},"Action's Appendix 1")," for the details of the transaction map."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"A specific rule is applied for inherit condition, if a field is not specified in the conditions, it assumes that it must have the same value as the previous transaction. Example, if code is ommited, this is assumed: ",(0,r.kt)("inlineCode",{parentName:"p"},"code: previous.code == next.code")),(0,r.kt)("p",{parentName:"admonition"},"This means that an empty inherit condition (",(0,r.kt)("inlineCode",{parentName:"p"},"condition inherit: []"),") means no changes is accepted, resulting in locking the chain.")),(0,r.kt)("h3",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Pass only if it is executed before a timestamp:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},"condition inherit: [\n    timestamp: next.timestamp < 1677598185\n]\n")),(0,r.kt)("p",null,'Pass only if the transaction is type "transfer", without any uco_transfers and at least one token_transfers:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition inherit: [\n    type: "transfer",\n    uco_transfers: Map.size() == 0,\n    token_transfers: Map.size() > 0\n]\n')),(0,r.kt)("p",null,"Pass only if chain has been closed (the code part) and there is a 2 UCO transfer to an address depending on the time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition inherit: [\n    code: "condition inherit: []",\n    uco_transfers:\n        if Time.now() >= 1674564088 do\n            ["00003bafdfb7a8e66b59de5692b79088063853bbd69a7d555faec906e6215e57ff98": 2]\n        else\n            ["0000ba28ce06631ff2ef4fe3dc89a34be13c0d252f8952bbfa3173b03dbef3c04afd": 2]\n        end\n]\n')),(0,r.kt)("p",null,'Pass only if the key "index" of the content is greater than the previous one:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition inherit do\n    json_path = "$.index"\n    if Json.path_match?(next.content, json_path) do\n        previous_index = Json.path_extract(previous.content, json_path)\n        new_index = Json.path_extract(next.content, json_path)\n\n        new_index > previous_index\n    else\n        false\n    end\nend\n')),(0,r.kt)("h2",{id:"condition-triggered-by-a-transaction"},"Condition triggered by a transaction"),(0,r.kt)("p",null,"Its purpose is to check the transaction that triggered an action on the contract. It must return a boolean."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},"condition triggered_by: transaction do\n  false\nend\n\ncondition triggered_by: transaction, on: refund() do\n  true\nend\n")),(0,r.kt)("p",null,"There are 2 global variables for this condition block:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"contract")," is the transaction of the current contract."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"transaction")," is the transaction that triggered the contract.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/actions#appendix-1-the-transaction-map"},"Action's Appendix 1")," for the details of the transaction map."),(0,r.kt)("h3",{id:"examples-1"},"Examples"),(0,r.kt)("p",null,"Pass only if the transaction that triggered the contract comes from a specific chain (a chain can be identified by it's genesis address):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},"condition triggered_by: transaction, as: [\n    address: Chain.get_genesis_address() == 0x00001234ab\n]\n")),(0,r.kt)("p",null,"Pass only if the transaction that triggered sent 10 UCOs to this contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},"condition triggered_by: transaction, as: [\n    uco_transfers: Map.get(contract.address) == 10\n]\n")),(0,r.kt)("p",null,"Pass only if the candidate is in the list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition triggered_by: transaction, on: vote(candidate) do\n    List.in?(["Peter", "Sofia", "Claire"], candidate)\nend\n')),(0,r.kt)("p",null,"Pass only if the secret is correct and the lock_time is in the future:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition triggered_by: transaction, on: withdraw(secret) do\n  valid_secret = Crypto.hash(secret) == State.get("secret_hash")\n  valid_time = Time.now() < State.get("lock_time")\n  valid_secret && valid_time\nend\n')),(0,r.kt)("p",null,"Same as previous but using throw:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition triggered_by: transaction, on: withdraw(secret) do\n  if Crypto.hash(secret) != State.get("secret_hash") do\n    throw code: 1, message: "invalid secret"\n  end\n\n  if Time.now() > State.get("lock_time") do\n    throw code: 2, message: "time expired"\n  end\n\n  true\nend\n')),(0,r.kt)("h2",{id:"condition-triggered-by-an-oracle"},"Condition triggered by an oracle"),(0,r.kt)("p",null,"Its purpose is to check the oracle transaction that triggered the contract. It must return a boolean. It is very useful because not every oracle transaction contains the data you need."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},"condition triggered_by: oracle do\n  true\nend\n")),(0,r.kt)("p",null,"There are 2 global variables for this condition block:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"contract")," is the transaction of the current contract."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"transaction")," is the oracle transaction that triggered the contract.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/actions#appendix-1-the-transaction-map"},"Action's Appendix 1")," for the details of the transaction map."),(0,r.kt)("h3",{id:"examples-2"},"Examples"),(0,r.kt)("p",null,"Pass only if the transaction's content is a JSON string including the UCO price in USD."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition triggered_by: oracle, as: [\n    content: Json.path_match?("$.uco.usd")\n]\n')),(0,r.kt)("p",null,"Pass only if the transaction's content is a JSON string including the Vancouver's weather and if it's raining there."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-elixir"},'condition triggered_by: oracle do\n    Json.path_match?(transaction.content, "$.canada.vancouver.raining?")\nend\n')))}u.isMDXComponent=!0},8209:(e,t,n)=>{n(67294)}}]);