"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1855],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>c});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(a),m=l,c=u["".concat(s,".").concat(m)]||u[m]||k[m]||i;return a?n.createElement(c,r(r({ref:t},p),{},{components:a})):n.createElement(c,r({ref:t},p))}));function c(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:l,r[1]=o;for(var d=2;d<i;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},83313:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>k,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(87462),l=(a(67294),a(3905));a(8209);const i={id:"library",title:"Smart Contracts - Library",sidebar_label:"Library",sidebar_position:4},r=void 0,o={unversionedId:"build/smart-contracts/language/library",id:"build/smart-contracts/language/library",title:"Smart Contracts - Library",description:"The Smart Contract library is composed of many modules with many functions in each.",source:"@site/docs/build/smart-contracts/language/library.md",sourceDirName:"build/smart-contracts/language",slug:"/build/smart-contracts/language/library",permalink:"/build/smart-contracts/language/library",draft:!1,tags:[],version:"current",lastUpdatedAt:1707858735,formattedLastUpdatedAt:"Feb 13, 2024",sidebarPosition:4,frontMatter:{id:"library",title:"Smart Contracts - Library",sidebar_label:"Library",sidebar_position:4},sidebar:"docs",previous:{title:"Actions",permalink:"/build/smart-contracts/language/actions"},next:{title:"Examples",permalink:"/build/smart-contracts/language/examples"}},s={},d=[{value:"String",id:"string",level:2},{value:"size/1",id:"size1",level:3},{value:"in?/2",id:"in2",level:3},{value:"to_number/1",id:"to_number1",level:3},{value:"from_number/1",id:"from_number1",level:3},{value:"to_hex/1",id:"to_hex1",level:3},{value:"to_uppercase/1",id:"to_uppercase1",level:3},{value:"to_lowercase/1",id:"to_lowercase1",level:3},{value:"Map",id:"map",level:2},{value:"new/0",id:"new0",level:3},{value:"size/1",id:"size1-1",level:3},{value:"get/2",id:"get2",level:3},{value:"get/3",id:"get3",level:3},{value:"set/3",id:"set3",level:3},{value:"keys/1",id:"keys1",level:3},{value:"values/1",id:"values1",level:3},{value:"delete/2",id:"delete2",level:3},{value:"List",id:"list",level:2},{value:"at/2",id:"at2",level:3},{value:"size/1",id:"size1-2",level:3},{value:"in?/2",id:"in2-1",level:3},{value:"empty?/1",id:"empty1",level:3},{value:"concat/2",id:"concat2",level:3},{value:"append/2",id:"append2",level:3},{value:"prepend/2",id:"prepend2",level:3},{value:"join/2",id:"join2",level:3},{value:"Regex",id:"regex",level:2},{value:"extract/2",id:"extract2",level:3},{value:"match?/2",id:"match2",level:3},{value:"scan/2",id:"scan2",level:3},{value:"Json",id:"json",level:2},{value:"path_extract/2",id:"path_extract2",level:3},{value:"path_match?/2",id:"path_match2",level:3},{value:"to_string/1",id:"to_string1",level:3},{value:"parse/1",id:"parse1",level:3},{value:"is_valid?/1",id:"is_valid1",level:3},{value:"Time",id:"time",level:2},{value:"now/0",id:"now0",level:3},{value:"Chain",id:"chain",level:2},{value:"get_genesis_address/1 <code>[I/O]</code>",id:"get_genesis_address1-io",level:3},{value:"get_first_transaction_address/1 <code>[I/O]</code>",id:"get_first_transaction_address1-io",level:3},{value:"get_genesis_public_key/1 <code>[I/O]</code>",id:"get_genesis_public_key1-io",level:3},{value:"get_burn_address/0",id:"get_burn_address0",level:3},{value:"get_transaction/1  <code>[I/O]</code>",id:"get_transaction1--io",level:3},{value:"get_last_address/1 <code>[I/O]</code>",id:"get_last_address1-io",level:3},{value:"get_last_transaction/1 <code>[I/O]</code>",id:"get_last_transaction1-io",level:3},{value:"get_previous_address/1",id:"get_previous_address1",level:3},{value:"get_balance/1 <code>[I/O]</code>",id:"get_balance1-io",level:3},{value:"get_uco_balance/1 <code>[I/O]</code>",id:"get_uco_balance1-io",level:3},{value:"get_token_balance/2 <code>[I/O]</code>",id:"get_token_balance2-io",level:3},{value:"get_token_balance/3 <code>[I/O]</code>",id:"get_token_balance3-io",level:3},{value:"get_tokens_balance/1 <code>[I/O]</code>",id:"get_tokens_balance1-io",level:3},{value:"get_tokens_balance/2 <code>[I/O]</code>",id:"get_tokens_balance2-io",level:3},{value:"Crypto",id:"crypto",level:2},{value:"hash/1",id:"hash1",level:3},{value:"hash/2",id:"hash2",level:3},{value:"hmac/1",id:"hmac1",level:3},{value:"hmac/2",id:"hmac2",level:3},{value:"hmac/3",id:"hmac3",level:3},{value:"sign_with_recovery/1",id:"sign_with_recovery1",level:3},{value:"Token",id:"token",level:2},{value:"fetch_id_from_address/1 <code>[I/O]</code>",id:"fetch_id_from_address1-io",level:3},{value:"Code",id:"code",level:2},{value:"is_same?/2",id:"is_same2",level:3},{value:"is_valid?/1",id:"is_valid1-1",level:3},{value:"Math",id:"math",level:2},{value:"pow/2",id:"pow2",level:3},{value:"trunc/1",id:"trunc1",level:3},{value:"sqrt/1",id:"sqrt1",level:3},{value:"rem/2",id:"rem2",level:3},{value:"Http",id:"http",level:2},{value:"request/1 <code>[I/O]</code>",id:"request1-io",level:3},{value:"request/2 <code>[I/O]</code>",id:"request2-io",level:3},{value:"request/3 <code>[I/O]</code>",id:"request3-io",level:3},{value:"request/4 <code>[I/O]</code>",id:"request4-io",level:3},{value:"request_many/1 <code>[I/O]</code>",id:"request_many1-io",level:3},{value:"Contract",id:"contract",level:2},{value:"call_function/3 <code>[I/O]</code>",id:"call_function3-io",level:3},{value:"set_type/1 <code>[Transaction]</code>",id:"set_type1-transaction",level:3},{value:"set_content/1 <code>[Transaction]</code>",id:"set_content1-transaction",level:3},{value:"set_code/1 <code>[Transaction]</code>",id:"set_code1-transaction",level:3},{value:"add_uco_transfer/1 <code>[Transaction]</code>",id:"add_uco_transfer1-transaction",level:3},{value:"add_uco_transfers/1 <code>[Transaction]</code>",id:"add_uco_transfers1-transaction",level:3},{value:"add_token_transfer/1 <code>[Transaction]</code>",id:"add_token_transfer1-transaction",level:3},{value:"add_token_transfers/1 <code>[Transaction]</code>",id:"add_token_transfers1-transaction",level:3},{value:"add_ownership/1 <code>[Transaction]</code>",id:"add_ownership1-transaction",level:3},{value:"add_ownerships/1 <code>[Transaction]</code>",id:"add_ownerships1-transaction",level:3},{value:"add_recipient/1 <code>[Transaction]</code>",id:"add_recipient1-transaction",level:3},{value:"add_recipients/1 <code>[Transaction]</code>",id:"add_recipients1-transaction",level:3},{value:"Evm",id:"evm",level:2},{value:"abi_encode/2",id:"abi_encode2",level:3},{value:"abi_decode/2",id:"abi_decode2",level:3}],p={toc:d},u="wrapper";function k(e){let{components:t,...a}=e;return(0,l.kt)(u,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The Smart Contract library is composed of many modules with many functions in each.\n",(0,l.kt)("strong",{parentName:"p"},"Unless it is explicitely written, the functions will not mutate their arguments"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"# Don't\nsold_items = [1,2,3]\nList.concat(sold_items, [4,5,6])\n\n# Do\nsold_items = [1,2,3]\nsold_items = List.concat(sold_items, [4,5,6])\n")),(0,l.kt)("admonition",{title:"function/arity",type:"note"},(0,l.kt)("p",{parentName:"admonition"},"In this page, the number after the slash indicates the arity of the function (number or arguments)."),(0,l.kt)("p",{parentName:"admonition"},"For example ",(0,l.kt)("inlineCode",{parentName:"p"},"size/1")," means the function ",(0,l.kt)("inlineCode",{parentName:"p"},"size")," has 1 argument.")),(0,l.kt)("admonition",{title:"Tagged functions",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Functions are tagged as ",(0,l.kt)("inlineCode",{parentName:"p"},"[Transaction]")," are special:"),(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},"They are only available in the ",(0,l.kt)("inlineCode",{parentName:"li"},"actions")," block."),(0,l.kt)("li",{parentName:"ul"},'They mutate an internal state, the "next transaction".'),(0,l.kt)("li",{parentName:"ul"},'This "next transaction" is initiated with current contract (all values but transfers are copied)')),(0,l.kt)("p",{parentName:"admonition"},"Other functions are tagged as ",(0,l.kt)("inlineCode",{parentName:"p"},"[I/O]")," and help to fetch data making network calls by either:"),(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},"requesting Archethic"),(0,l.kt)("li",{parentName:"ul"},"requesting the outside world"))),(0,l.kt)("h2",{id:"string"},"String"),(0,l.kt)("h3",{id:"size1"},"size/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.size("hello")   # 5\nString.size("\u4f60\u597d")     # 2\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Returns the number of characters in ",(0,l.kt)("inlineCode",{parentName:"p"},"str"),"."),(0,l.kt)("h3",{id:"in2"},"in?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.in?("bob,alice,julia", "alice")  # true\nString.in?("bob,alice,julia", "fred")   # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str1")," the haystack"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str2")," the needle")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"needle")," is in the ",(0,l.kt)("inlineCode",{parentName:"p"},"haystack"),"."),(0,l.kt)("h3",{id:"to_number1"},"to_number/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_number("12")     # 12\nString.to_number("-12")    # -12\nString.to_number("12.1")   # 12.1\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Returns the number which text representation is ",(0,l.kt)("inlineCode",{parentName:"p"},"str"),"."),(0,l.kt)("h3",{id:"from_number1"},"from_number/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.from_number(13)     # "13"\nString.from_number(13.2)   # "13.2"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number")," the number")),(0,l.kt)("p",null,"Returns the text representation of ",(0,l.kt)("inlineCode",{parentName:"p"},"number"),"."),(0,l.kt)("h3",{id:"to_hex1"},"to_hex/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_hex("592ac76afa") # "592AC76AFA"\nString.to_hex("592AC76AFA") # "592AC76AFA"\nString.to_hex("hello") # "68656C6C6F"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Return the text representation of hexadecimal ",(0,l.kt)("inlineCode",{parentName:"p"},"str"),".\nIf ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," is already an hex it just uppercase it"),(0,l.kt)("h3",{id:"to_uppercase1"},"to_uppercase/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_uppercase("Ars\xe8ne Lupin") # "ARS\xc8NE LUPIN"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Return the ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," in uppercase."),(0,l.kt)("h3",{id:"to_lowercase1"},"to_lowercase/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'String.to_lowercase("Sherlock Holmes") # "sherlock holmes"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the string")),(0,l.kt)("p",null,"Return the ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," in lowercase."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"map"},"Map"),(0,l.kt)("h3",{id:"new0"},"new/0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Map.new() # empty map\n")),(0,l.kt)("p",null,"Returns an empty map. There is no shorthand notation."),(0,l.kt)("h3",{id:"size1-1"},"size/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.size(key1: "value", key2: "value2") # 2\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map")),(0,l.kt)("p",null,"Returns the number of keys in ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("h3",{id:"get2"},"get/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.get([key1: "value", key2: "value2"], "key1") # "value"\nMap.get([key1: "value", key2: "value2"], "key3") # nil\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key")),(0,l.kt)("p",null,"Returns the value at ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"nil")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," is not in the ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"There is a shorthand notation ",(0,l.kt)("inlineCode",{parentName:"p"},"map.key")," when key is not a variable.")),(0,l.kt)("h3",{id:"get3"},"get/3"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.get([key1: "value", key2: "value2"], "key1", "not in map") # "value"\nMap.get([key1: "value", key2: "value2"], "key3", "not in map") # "not in map"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"default")," the default value")),(0,l.kt)("p",null,"Returns the value at ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," is not in the ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("h3",{id:"set3"},"set/3"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.set([key1: "value", key2: "value2"], "key1", "valueX") # [key1: "valueX", key2: "value2"]\nMap.get([key1: "value", key2: "value2"], "key3", "value3") # [key1: "value", key2: "value2, key3: "value3"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," the value to set")),(0,l.kt)("p",null,"Returns a copy of ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," where the value at ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"value"),"."),(0,l.kt)("h3",{id:"keys1"},"keys/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.keys(key1: "value", key2: "value2") # ["key1", "key2"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map")),(0,l.kt)("p",null,"Returns the list of keys in ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"Use it with a ",(0,l.kt)("inlineCode",{parentName:"p"},"for loop")," to iterate on a map!"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre"},"for key in Map.keys(map) do\n    ...\n    value = map[key]\n    ...\nend\n"))),(0,l.kt)("h3",{id:"values1"},"values/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.values(key1: "value", key2: "value2") # ["value", "value2"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map")),(0,l.kt)("p",null,"Returns the list of values in ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,l.kt)("h3",{id:"delete2"},"delete/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Map.delete([key1: "value", key2: "value2"], "key2") # [key1: "value"]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map")," the map"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key to remove")),(0,l.kt)("p",null,"Returns a copy of the ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," without the value at given ",(0,l.kt)("inlineCode",{parentName:"p"},"key"),"."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"list"},"List"),(0,l.kt)("p",null,"Lists are actually ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linked_list"},"Linked List"),"."),(0,l.kt)("h3",{id:"at2"},"at/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.at(["a", "b", "c"], 0)     # "a"\nList.at(["a", "b", "c"], 1)     # "b"\nList.at(["a", "b", "c"], 2)     # "c"\nList.at([], 0)                  # nil\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"index")," the index (zero-based)")),(0,l.kt)("p",null,"Returns the element at ",(0,l.kt)("inlineCode",{parentName:"p"},"index")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("h3",{id:"size1-2"},"size/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.size([])           # 0\nList.size([1,2,3,4])    # 4\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list")),(0,l.kt)("p",null,"Returns the number of keys in ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("h3",{id:"in2-1"},"in?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.in?(["bob", "alice"], "alice") # true\nList.in?(["bob", "alice"], "fred")  # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the haystack"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"element")," the needle")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"needle")," is in the ",(0,l.kt)("inlineCode",{parentName:"p"},"haystack"),"."),(0,l.kt)("h3",{id:"empty1"},"empty?/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.empty?([])         # true\nList.empty?(["apple"])  # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," is empty or not."),(0,l.kt)("h3",{id:"concat2"},"concat/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.concat([], [])         # []\nList.concat([1,2], [3,4])   # [1,2,3,4]\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list1")," a list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list2")," another list")),(0,l.kt)("p",null,"Returns a new list where ",(0,l.kt)("inlineCode",{parentName:"p"},"list2")," is concatenated to ",(0,l.kt)("inlineCode",{parentName:"p"},"list1"),"."),(0,l.kt)("h3",{id:"append2"},"append/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.append([], 1)    # [1]\nList.append([1], 2)   # [1,2]\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"element")," the element")),(0,l.kt)("p",null,"Returns a new list where ",(0,l.kt)("inlineCode",{parentName:"p"},"element")," is appended to the end of ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"If order doesn't matter, we suggest to use ",(0,l.kt)("inlineCode",{parentName:"p"},"prepend/2")," instead (Complexity: O(1) instead of O(n)).")),(0,l.kt)("h3",{id:"prepend2"},"prepend/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"List.prepend([], 1)    # [1]\nList.prepend([1], 0)   # [0,1]\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"element")," the element")),(0,l.kt)("p",null,"Returns a new list where ",(0,l.kt)("inlineCode",{parentName:"p"},"element")," is appended to the start of ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,l.kt)("h3",{id:"join2"},"join/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'List.join([], ", ")    # ""\nList.join(["Mike", "Robert", "Joe"], ", ")   # "Mike, Robert, Joe"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list")," the list of strings"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"separator")," the separator")),(0,l.kt)("p",null,"Returns a string where all ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),"'s elements have been joined with ",(0,l.kt)("inlineCode",{parentName:"p"},"separator")," separator."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"regex"},"Regex"),(0,l.kt)("h3",{id:"extract2"},"extract/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Regex.extract("123456abc", "[0-9]+")    # "123456"\nRegex.extract("voodoo", "[abc]")        # ""\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"text")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pattern")," the element")),(0,l.kt)("p",null,"Returns the data from ",(0,l.kt)("inlineCode",{parentName:"p"},"text")," extract via the regex ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern"),"."),(0,l.kt)("h3",{id:"match2"},"match?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Regex.match?("123456", "^[0-9]+$")      # true\nRegex.match?("123456abc", "^[0-9]+$")   # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"text")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pattern")," the element")),(0,l.kt)("p",null,"Returns whether the ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern")," matches the ",(0,l.kt)("inlineCode",{parentName:"p"},"text")," or not."),(0,l.kt)("h3",{id:"scan2"},"scan/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Regex.scan("foo", "bar")                                    # []\nRegex.scan("toto,123\\ntutu,456\\n", "toto,([0-9]+)")         # ["123"]\nRegex.scan("toto,123\\ntutu,456\\n", "t.t.,([0-9]+)")         # ["123", "456"]\nRegex.scan("A0B1C2,123\\nD3E4F5,456\\n", "^(\\\\w+),(\\\\d+)$")   # [["A0B1C2", "123"], ["D3E4F5", "456"]]\n\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"text")," the list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pattern")," the element")),(0,l.kt)("p",null,"Returns the data from ",(0,l.kt)("inlineCode",{parentName:"p"},"text")," extract via the regex ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern"),"."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"This function requires the usage of capture groups (subexpressions).")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"json"},"Json"),(0,l.kt)("p",null,"Functions to manipulate JSON strings."),(0,l.kt)("p",null,"Useful resources:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://goessner.net/articles/JsonPath/"},"JSONPath documentation"))),(0,l.kt)("h3",{id:"path_extract2"},"path_extract/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.path_extract("{ \\"firstName\\": \\"John\\", \\"lastName\\": \\"Doe\\"}", "$.firstName") # "John"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"path")," the path")),(0,l.kt)("p",null,"Returns the data at ",(0,l.kt)("inlineCode",{parentName:"p"},"path")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"json"),"."),(0,l.kt)("h3",{id:"path_match2"},"path_match?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.path_match?("{\\"1622541930\\":{\\"uco\\":{\\"eur\\":0.176922,\\"usd\\":0.21642}}}", "$.*.uco.usd") # true\nJson.path_match?("{\\"1622541930\\":{\\"uco\\":{\\"eur\\":0.176922,\\"usd\\":0.21642}}}", "$.*.uco.aud") # false\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"path")," the path")),(0,l.kt)("p",null,"Returns if there is a value at ",(0,l.kt)("inlineCode",{parentName:"p"},"path")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"json"),"."),(0,l.kt)("h3",{id:"to_string1"},"to_string/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.to_string(1)           # "1"\nJson.to_string("str")       # "\\"str\\""\nJson.to_string([1,2,3])     # "[1,2,3]"\nJson.to_string(foo: "bar")  # "{\\"foo\\":\\"bar\\"}"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"any")," anything")),(0,l.kt)("p",null,"Returns the Json representation of ",(0,l.kt)("inlineCode",{parentName:"p"},"any"),"."),(0,l.kt)("h3",{id:"parse1"},"parse/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.parse("1")                     # "1"\nJson.parse("\\"str\\"")               # "str"\nJson.parse("[1,2,3]")               # [1,2,3]\nJson.parse("{\\"foo\\":\\"bar\\"}")     # foo: "bar"\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string")),(0,l.kt)("p",null,"Returns the value represented by ",(0,l.kt)("inlineCode",{parentName:"p"},"json"),"."),(0,l.kt)("h3",{id:"is_valid1"},"is_valid?/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Json.is_valid?("str")        # false\nJson.is_valid?("\\"str\\"")    # true\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"json")," the json string")),(0,l.kt)("p",null,"Returns whether the string is valid JSON or not."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"time"},"Time"),(0,l.kt)("h3",{id:"now0"},"now/0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Time.now()  # 1677493444\n")),(0,l.kt)("p",null,"Returns an approximation of current time (seconds since epoch).\n",(0,l.kt)("strong",{parentName:"p"},"It will always return the same value within a contract.")),(0,l.kt)("admonition",{title:"Why an approximation?",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Because we need the smart contracts to be determinist.\nMany nodes will run them and all of them must produce the same transaction to validate a contract's execution.")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"chain"},"Chain"),(0,l.kt)("h3",{id:"get_genesis_address1-io"},"get_genesis_address/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_genesis_address("000012345...") # "000056789..."\nChain.get_genesis_address("000012345...") # "000012345..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the genesis address of the transaction chain that contains a transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),". If there is no transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),", it returns ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("h3",{id:"get_first_transaction_address1-io"},"get_first_transaction_address/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_first_transaction_address("000012345...") # "000056789..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the address of the first transaction of the transaction chain that contains a transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("admonition",{type:"danger"},(0,l.kt)("p",{parentName:"admonition"},"[IT CURRENTLY CRASH IF THERE IS NO TRANSACTION]")),(0,l.kt)("h3",{id:"get_genesis_public_key1-io"},"get_genesis_public_key/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_genesis_public_key("00013B08D...") # "000108A5C..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"public_key")," the public key")),(0,l.kt)("p",null,"Returns the genesis public key of ",(0,l.kt)("inlineCode",{parentName:"p"},"public_key"),"."),(0,l.kt)("h3",{id:"get_burn_address0"},"get_burn_address/0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_burn_address() # "0000000000..."\n')),(0,l.kt)("p",null,"Returns the burn address."),(0,l.kt)("h3",{id:"get_transaction1--io"},"get_transaction/1  ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_transaction(0x00ABCD..) # [address: "00ABCD..", content: "...", uco_transfers: [], ...]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),". If there is no transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),", it returns ",(0,l.kt)("inlineCode",{parentName:"p"},"nil"),". See ",(0,l.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/actions#appendix-1-the-transaction-map"},"Appendix 1"),"."),(0,l.kt)("h3",{id:"get_last_address1-io"},"get_last_address/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_last_address(0x00ABCD..) # "00EFAB..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the latest transaction address of the chain that contains ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("h3",{id:"get_last_transaction1-io"},"get_last_transaction/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_last_transaction(0x00ABCD..) # [address: "00EFAB..", content: "...", uco_transfers: [], ...]\nChain.get_last_transaction(0x00ABCF..) # nil\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the transaction address")),(0,l.kt)("p",null,"Returns the latest transaction of the chain that contains the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),". May return nil if ",(0,l.kt)("inlineCode",{parentName:"p"},"address")," does not exist. See ",(0,l.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/actions#appendix-1-the-transaction-map"},"Appendix 1"),"."),(0,l.kt)("h3",{id:"get_previous_address1"},"get_previous_address/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Chain.get_previous_address(0x00ABCD..) # "00EFAB.."\nChain.get_previous_address(transaction) # "0014AC.."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"previous_public_key")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"transaction")," either a transaction map or a the previous_public_key")),(0,l.kt)("p",null,"Returns previous transaction's address. Usually called with a ",(0,l.kt)("inlineCode",{parentName:"p"},"transaction"),", it is also possible to call it with the ",(0,l.kt)("inlineCode",{parentName:"p"},"previous_public_key")," directly."),(0,l.kt)("h3",{id:"get_balance1-io"},"get_balance/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"balance = Chain.get_balance(0x00ABCD..)\nuco_balance = balance.uco # 181812.87\ntestcoin_balance = Map.get(balance.tokens, [token_address: 0x00ABCD.., token_id: 0]) # 4756.5401\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the address of a transaction in the chain you're interested in")),(0,l.kt)("p",null,"Returns the balance of the chain that contains the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("p",null,"The return value is a map with two keys ",(0,l.kt)("inlineCode",{parentName:"p"},"uco")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens"),". The value behind ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," is a map where the keys are tokens' identifiers (",(0,l.kt)("inlineCode",{parentName:"p"},"[token_address: HEX, token_id: POS_INT]"),") and the values are floats."),(0,l.kt)("p",null,"Useful if you need to retrieve the entire list of tokens (and uco) at the same time."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If you're only interested at UCO, consider ",(0,l.kt)("a",{parentName:"li",href:"#get_uco_balance1-io"},"get_uco_balance/1"),"."),(0,l.kt)("li",{parentName:"ul"},"If you're only interested in a specific token, consider ",(0,l.kt)("a",{parentName:"li",href:"#get_token_balance2-io"},"get_token_balance/2"),"."),(0,l.kt)("li",{parentName:"ul"},"If you're only interested in a few specific tokens, consider ",(0,l.kt)("a",{parentName:"li",href:"#get_tokens_balance2-io"},"get_tokens_balance/2"),".")),(0,l.kt)("h3",{id:"get_uco_balance1-io"},"get_uco_balance/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Chain.get_uco_balance(0x00ABCD..) # 14.26239\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the address of a transaction in the chain you're interested in")),(0,l.kt)("p",null,"Returns the amount of UCO in the chain that contains the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("h3",{id:"get_token_balance2-io"},"get_token_balance/2 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("p",null,"Same as ",(0,l.kt)("a",{parentName:"p",href:"#get_token_balance3-io"},"get_token_balance/3")," called with ",(0,l.kt)("inlineCode",{parentName:"p"},"token_id: 0"),"."),(0,l.kt)("h3",{id:"get_token_balance3-io"},"get_token_balance/3 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"transaction_address = 0x00ABCD..\nfungible_token_address = 0x00BCDE..\nnon_fungible_token_address = 0x00FEDC..\nChain.get_token_balance(transaction_address, fungible_token_address, 0) # 14.26239591\nChain.get_token_balance(transaction_address, non_fungible_token_address, 1) # 1\nChain.get_token_balance(transaction_address, non_fungible_token_address, 2) # 0\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the address of a transaction in the chain you're interested in"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"token_address")," the address of the transaction that defined the token"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"token_id")," the index of the element in the collection (0 for fungible tokens)")),(0,l.kt)("p",null,"Returns the token balance of the token defined at ",(0,l.kt)("inlineCode",{parentName:"p"},"token_address")," in the chain that contains the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),".\nNon-fungible tokens must precise the ",(0,l.kt)("inlineCode",{parentName:"p"},"token_id")," (index of the token in the collection)."),(0,l.kt)("h3",{id:"get_tokens_balance1-io"},"get_tokens_balance/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"balance = Chain.get_tokens_balance(0x00ABCD..)\nabdecoin_balance = Map.get(balance, [token_address: 0x00ABDE.., token_id: 0]) # 8.90800012\ndefacoin_balance = Map.get(balance, [token_address: 0x00DEFA.., token_id: 0]) # 4.05902597\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the address of a transaction in the chain you're interested in")),(0,l.kt)("p",null,"Returns a subset of the token balance of the chain that contains the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),".\nThe return value is a map where the keys are the tokens' identifiers: ",(0,l.kt)("inlineCode",{parentName:"p"},"[token_address: HEX, token_id: POS_INT]")," and the value are floats."),(0,l.kt)("p",null,"Useful if you need to retrieve many tokens at the same time."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If you're only interested in a specific token, consider  ",(0,l.kt)("a",{parentName:"li",href:"#get_token_balance2-io"},"get_token_balance/2"),".")),(0,l.kt)("h3",{id:"get_tokens_balance2-io"},"get_tokens_balance/2 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"balance = Chain.get_tokens_balance(0x00ABCD.., [\n  [token_address: 0x00DEFA.., token_id: 1],\n  [token_address: 0x00DEFA.., token_id: 2]\n])\nnft1 = Map.get(balance, [token_address: 0x00DEFA.., token_id: 1]) # 1\nnft2 = Map.get(balance, [token_address: 0x00DEFA.., token_id: 2]) # 0\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the address of a transaction in the chain you're interested in"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"tokens_identifiers")," the list of tokens' identifiers (",(0,l.kt)("inlineCode",{parentName:"li"},"[token_address: HEX, token_id: POS_INT]"),") to return")),(0,l.kt)("p",null,"Returns a subset of the token balance of the chain that contains the transaction at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),".\nThe return value is a map where the keys are the tokens' identifiers: ",(0,l.kt)("inlineCode",{parentName:"p"},"[token_address: HEX, token_id: POS_INT]")," and the value are floats."),(0,l.kt)("p",null,"Useful if you need to retrieve many tokens at the same time."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If you're only interested in a specific token, consider ",(0,l.kt)("a",{parentName:"li",href:"#get_token_balance2-io"},"get_token_balance/2"),".")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"crypto"},"Crypto"),(0,l.kt)("h3",{id:"hash1"},"hash/1"),(0,l.kt)("p",null,"Equivalent to ",(0,l.kt)("a",{parentName:"p",href:"#hash2"},"hash/2"),' with the second argument "sha256".'),(0,l.kt)("h3",{id:"hash2"},"hash/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Crypto.hash("my text", "sha256") # "7330D2B39CA35EA..."\nCrypto.hash("my text", "sha512") # "A3D7E45A0D9BE5F..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str")," the text to hash"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"algo"),' the hash algorithm ("sha256", "sha512", "sha3_256", "sha3_512", "blake2b", "keccak256")')),(0,l.kt)("p",null,"Returns the hash of ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," by using ",(0,l.kt)("inlineCode",{parentName:"p"},"algo")," algorithm."),(0,l.kt)("h3",{id:"hmac1"},"hmac/1"),(0,l.kt)("p",null,"Equivalent to ",(0,l.kt)("a",{parentName:"p",href:"#hmac2"},"hmac/2"),' with the second argument "sha256".'),(0,l.kt)("h3",{id:"hmac2"},"hmac/2"),(0,l.kt)("p",null,"Equivalent to ",(0,l.kt)("a",{parentName:"p",href:"#hmac3"},"hmac/3")," with the third argument being a key created from the contract seed and secret data known by nodes.\nThe key created is deterministic and will always be the same for a contract."),(0,l.kt)("h3",{id:"hmac3"},"hmac/3"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Crypto.hmac("my text") # "374C7527733556..."\nCrypto.hmac("my text", "sha256") # "374C7527733556..."\nCrypto.hmac("my text", "sha256", "secret_key") # "901A365FF22B895..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"data")," the data to hash (if the data is hexadecimal it will be decoded in binary)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"algo"),' the hash algorithm ("sha256", "sha512", "sha3_256", "sha3_512")'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," the key to perform the hmac (if the data is hexadecimal it will be decoded in binary)")),(0,l.kt)("p",null,"Returns the hmac of ",(0,l.kt)("inlineCode",{parentName:"p"},"data")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," using ",(0,l.kt)("inlineCode",{parentName:"p"},"algo"),"."),(0,l.kt)("h3",{id:"sign_with_recovery1"},"sign_with_recovery/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'signature_payload = Crypto.hash("tintin", "keccak256")\nCrypto.sign_with_recovery(signature_payload) # [r: "00ABCD...", s: "00BCDE...", v: 0]\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hash")," the hash to sign")),(0,l.kt)("p",null,"Return a signature of the given ",(0,l.kt)("inlineCode",{parentName:"p"},"hash"),"."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"token"},"Token"),(0,l.kt)("h3",{id:"fetch_id_from_address1-io"},"fetch_id_from_address/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Token.fetch_id_from_address("000012345") # "3C21EF708BF11B4232..."\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address")," the token address")),(0,l.kt)("p",null,"Returns the token's id of the token at ",(0,l.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"code"},"Code"),(0,l.kt)("h3",{id:"is_same2"},"is_same?/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'code = """\n@version\n\ncondition triggered_by: transaction, as: []\n\nactions triggered_by: transaction do\n  Contract.add_uco_transfer to: 0x1234, amount: 15.5\nend\n"""\n\nCode.is_same?(code, transaction.code)\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"first_code")," a string containing a smart contract code"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"second_code")," a string containing a smart contract code")),(0,l.kt)("p",null,"Return true if codes are the same, false otherwise.\nThis function is more accurate than comparing two strings, as it convert code into structured AST and compare only code instruction and not line numbers, carriage return ..."),(0,l.kt)("h3",{id:"is_valid1-1"},"is_valid?/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'code = """\n@version\n\ncondition triggered_by: transaction, as: []\n\nactions triggered_by: transaction do\n  Contract.add_uco_transfer to: 0x1234, amount: 15.5\nend\n"""\n\nCode.is_valid?(code)\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"code")," a string containing a smart contract code")),(0,l.kt)("p",null,"Returns true if the code is valid according to Archethic smart contracts language, false otherwise"),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"math"},"Math"),(0,l.kt)("h3",{id:"pow2"},"pow/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Math.pow(2, 3)\n# 8\nMath.pow(1.7, 8)\n# 69.75757441\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number")," the number to apply the power"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"exponent")," the exponent of the power")),(0,l.kt)("p",null,"Returns the result of the power of number by exponent."),(0,l.kt)("h3",{id:"trunc1"},"trunc/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Math.trunc(8.32)\n# 8\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number")," the number to truncate")),(0,l.kt)("p",null,"Returns the truncated number as an integer."),(0,l.kt)("h3",{id:"sqrt1"},"sqrt/1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Math.sqrt(16)\n# 4\nMath.sqrt(12.5)\n# 3.53553390\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number")," the number to calculate the square root")),(0,l.kt)("p",null,"Returns the square root if the number."),(0,l.kt)("h3",{id:"rem2"},"rem/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Math.rem(2.1, 3)\n# 2.1\nMath.rem(10, 3)\n# 1\nMath.rem(-10, 3)\n# -1\nMath.rem(10.2, 1)\n# 0.2\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"dividend")," the number to divid"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"divisor")," the number which divid")),(0,l.kt)("p",null,"Returns the remainder (modulo) of a division."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"http"},"Http"),(0,l.kt)("h3",{id:"request1-io"},"request/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("p",null,"Similar to ",(0,l.kt)("a",{parentName:"p",href:"#request2-io"},"request/2")," with ",(0,l.kt)("inlineCode",{parentName:"p"},'method: "GET"'),"."),(0,l.kt)("h3",{id:"request2-io"},"request/2 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("p",null,"Similar to ",(0,l.kt)("a",{parentName:"p",href:"#request3-io"},"request/3")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"headers: Map.new()"),"."),(0,l.kt)("h3",{id:"request3-io"},"request/3 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("p",null,"Similar to ",(0,l.kt)("a",{parentName:"p",href:"#request4-io"},"request/4")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"body: nil"),"."),(0,l.kt)("h3",{id:"request4-io"},"request/4 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'response = Http.request("https://fakerapi.it/api/v1/addresses?_quantity=1&_seed=watermelon", "GET", Map.new(), nil) # [status: 200, body: "..."]\nif response.status == 200 do\n    # do something with response.body\nend\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"url")," the url to fetch"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"method")," the HTTP method (",(0,l.kt)("inlineCode",{parentName:"li"},'"GET"'),", ",(0,l.kt)("inlineCode",{parentName:"li"},'"POST"'),", ",(0,l.kt)("inlineCode",{parentName:"li"},'"PUT"'),", ",(0,l.kt)("inlineCode",{parentName:"li"},'"DELETE"')," or ",(0,l.kt)("inlineCode",{parentName:"li"},'"PATCH"'),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"headers")," the HTTP headers"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"body")," the HTTP body")),(0,l.kt)("p",null,"Performs a HTTP request and returns a map with ",(0,l.kt)("inlineCode",{parentName:"p"},"status")," (integer) and ",(0,l.kt)("inlineCode",{parentName:"p"},"body")," (string)."),(0,l.kt)("p",null,"This status integer can be any ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"},"HTTP status code"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The URL must use HTTPS protocol."),(0,l.kt)("li",{parentName:"ul"},"The response body's size must be less than 256KB."),(0,l.kt)("li",{parentName:"ul"},"The response must be received in less than 2 seconds."),(0,l.kt)("li",{parentName:"ul"},"The response must be idempotent (= identical every time it is called)"),(0,l.kt)("li",{parentName:"ul"},"Only 1 call of either ",(0,l.kt)("inlineCode",{parentName:"li"},"request/1,2,3,4")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"request_many/1")," is allowed per execution.")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"The function raises if these requirements are not meet.")),(0,l.kt)("admonition",{title:"Disclaimer",type:"danger"},(0,l.kt)("p",{parentName:"admonition"},"We discourage to call services that change their internal state directly (such as writing to a database or notifying a user). Because Archethic ",(0,l.kt)("strong",{parentName:"p"},"relies on atomic commitment of all storage nodes"),", it may happen that atomic commitment is not reached and the transaction resulting of a Smart Contract is not validated."),(0,l.kt)("p",{parentName:"admonition"},"Instead, you should notify the service of the transaction being validated. The service subscribes to that transaction via the GraphQL API, and once it receives a confirmation, it should act accordingly.")),(0,l.kt)("h3",{id:"request_many1-io"},"request_many/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'responses = Http.request_many([\n    [url: "https://fakerapi.it/api/v1/users?_quantity=1&_gender=male&_seed=cucumber"],\n    [url: "https://fakerapi.it/api/v1/users?_quantity=1&_gender=female&_seed=tomato", method: "GET", headers: Map.new(), body: nil]\n])\nfor r in responses do\n    if r.status == 200 do\n        # do something with r.body\n    end\nend\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"request")," a list of requests to perform")),(0,l.kt)("p",null,"Performs a HTTP request and returns a map with ",(0,l.kt)("inlineCode",{parentName:"p"},"status")," (integer) and ",(0,l.kt)("inlineCode",{parentName:"p"},"body")," (string). Order and length is preserved."),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"#request4-io"},"request/4")," for rules and more details."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"contract"},"Contract"),(0,l.kt)("h3",{id:"call_function3-io"},"call_function/3 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[I/O]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.call_function(0x0000ABCD..., "add", [1, 2])\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"contract_address")," the contract's adddress"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"function_name")," the function name"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"args")," the list of arguments to call the function with")),(0,l.kt)("p",null,"Calls the exported function ",(0,l.kt)("inlineCode",{parentName:"p"},"function_name")," of the Smart Contract at ",(0,l.kt)("inlineCode",{parentName:"p"},"contract_address")," with given ",(0,l.kt)("inlineCode",{parentName:"p"},"args")," and return the result value."),(0,l.kt)("h3",{id:"set_type1-transaction"},"set_type/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.set_type("transfer")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type"),' the transaction type ("contract", "transfer", "data", "hosting")')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to be of type ",(0,l.kt)("inlineCode",{parentName:"p"},"type"),"."),(0,l.kt)("h3",{id:"set_content1-transaction"},"set_content/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.set_content("Hello Smart Contract")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"content")," the transaction's content (we usually use this as the state of the smart contract)")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction content to be ",(0,l.kt)("inlineCode",{parentName:"p"},"content"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"While ",(0,l.kt)("inlineCode",{parentName:"p"},"content")," is always a string when you read it, it is possible here to send an integer or a float for convenience.\nFor any other data structure, you should serialize it with the ",(0,l.kt)("a",{parentName:"p",href:"/build/smart-contracts/language/library#json"},"Json module")," for example.")),(0,l.kt)("h3",{id:"set_code1-transaction"},"set_code/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.set_code("@version 1\\ncondition inherit: []")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"code")," the code")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction code to be ",(0,l.kt)("inlineCode",{parentName:"p"},"code"),"."),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},'This example "closes" the contract, by adding an ',(0,l.kt)("inlineCode",{parentName:"p"},"condition inherit")," that doesn't accept anything. It will be impossible to create a new transaction in this chain.")),(0,l.kt)("h3",{id:"add_uco_transfer1-transaction"},"add_uco_transfer/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.add_uco_transfer(to: "000012345...", amount: 1)\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"uco_transfer")," a map with two keys:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"to"),": the destination address"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"amount"),": the number of UCO")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"uco_transfer"),"."),(0,l.kt)("h3",{id:"add_uco_transfers1-transaction"},"add_uco_transfers/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_uco_transfer1-transaction"},"add_uco_transfer/1")," for each element of the list"),(0,l.kt)("h3",{id:"add_token_transfer1-transaction"},"add_token_transfer/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.add_token_transfer(\n    to: "000012345...",\n    amount: 1.2,\n    token_address: "000023456...")\nContract.add_token_transfer(\n    to: "000012345...",\n    amount: 1.2,\n    token_id: 4,\n    token_address: "000023456...")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"token_transfer")," a map with three or four keys:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"to"),": the destination address"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"amount"),": the number of UCO"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"token_address"),": the transaction address of the token"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[token_id]"),": an optional integer to specify which index in the list (used for the NFTs)")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"token_transfer"),"."),(0,l.kt)("h3",{id:"add_token_transfers1-transaction"},"add_token_transfers/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_token_transfer1-transaction"},"add_token_transfer/1")," for each element of the list"),(0,l.kt)("h3",{id:"add_ownership1-transaction"},"add_ownership/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'authorized_keys = Map.new()\nauthorized_keys = Map.set(authorized_keys, public_key, encoded_secret_key)\nContract.add_ownership(\n    secret: "ENCODED_SECRET1",\n    authorized_keys: authorized_keys\n)\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ownership")," a map with two keys:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"secret"),": the encoded secret"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"authorized_keys"),": a map where the keys are the ",(0,l.kt)("inlineCode",{parentName:"li"},"public_keys")," and the values are the ",(0,l.kt)("inlineCode",{parentName:"li"},"encoded_secret_keys")," (the keys to decode the secret encoded by each ",(0,l.kt)("inlineCode",{parentName:"li"},"public_key"),")")))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"It is the developer's job to encode the secret & the secret key for each authorized key.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"ownership"),"."),(0,l.kt)("h3",{id:"add_ownerships1-transaction"},"add_ownerships/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_ownership1-transaction"},"add_ownership/1")," for each element of the list"),(0,l.kt)("h3",{id:"add_recipient1-transaction"},"add_recipient/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},'Contract.add_recipient("000012345...")\n')),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"address"),": a transaction address (one with a smart contract)")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutates")," the next transaction to add the ",(0,l.kt)("inlineCode",{parentName:"p"},"address")," in the recipients."),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Recipients are used to trigger smart contracts")),(0,l.kt)("h3",{id:"add_recipients1-transaction"},"add_recipients/1 ",(0,l.kt)("inlineCode",{parentName:"h3"},"[Transaction]")),(0,l.kt)("p",null,"Equivalent to call ",(0,l.kt)("a",{parentName:"p",href:"#add_recipient1-transaction"},"add_recipients/1")," for each element of the list"),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"evm"},"Evm"),(0,l.kt)("h3",{id:"abi_encode2"},"abi_encode/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Evm.abi_encode(signature, data)\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"signature"),': the function or tuple signature (ex: "baz(uint,address)")'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"data"),": the data to encode")),(0,l.kt)("p",null,"Encodes the given ",(0,l.kt)("inlineCode",{parentName:"p"},"data")," according to the ",(0,l.kt)("inlineCode",{parentName:"p"},"signature"),"."),(0,l.kt)("h3",{id:"abi_decode2"},"abi_decode/2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-elixir"},"Evm.abi_decode(signature, encoded_data)\n")),(0,l.kt)("p",null,"Parameters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"signature"),': the function or tuple signature (ex: "baz(uint,address)")'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"encoded_data"),": the data to decode")),(0,l.kt)("p",null,"Decodes the given ",(0,l.kt)("inlineCode",{parentName:"p"},"encoded_data")," according to the ",(0,l.kt)("inlineCode",{parentName:"p"},"signature"),"."))}k.isMDXComponent=!0},8209:(e,t,a)=>{a(67294)}}]);